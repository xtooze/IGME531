Toolbox 1: The program is written in C#, and run by running the program.cs file. It then writes the shapes the user has inputed in the WriteSVG function to a .svg file, using the functions found in the DrawFunctions.cs file. I used this to make the recreation, and then also the variation, which is made of circles. I chose to work with circles because it strips the rotational aspect from the piece, which changes how I view it.

Toolbox 2: The program is written in C#, and run by running the program.cs file. It then writes the shapes the user has inputed in the WriteSVG function to a .svg file, using the functions found in the DrawFunctions.cs file. I made my recreation using polyline functions. Then, for the variation, I upped the variance and changes the shapes from squares to spirals, to up the motion feel.

Toolbox 3: The program is written in C#, and run by running the program.cs file. It then writes the shapes the user has inputed in the WriteSVG function to a .svg file, using the functions found in the DrawFunctions.cs file. I made my recration by applying rotations, then translations, to shapes with increasing extemeness the further down the page the shape was.

Toolbox 4: The program is written in C#, and run by running the program.cs file. It then writes the shapes the user has inputed in the WriteSVG function to a .svg file, using the functions found in the DrawFunctions.cs file. It also makes use of the Noise.cs file, which is sourced from https://github.com/Auburn/FastNoiseLite. The program uses perlin noise to generate a 100x100 2d array, and if the values are too large, removes the chunks to create interuptions in the artwork. For the variation, it also uses the 2d array for rotation, so the lines have a flow instead of completely random variance.